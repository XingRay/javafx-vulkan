//
// Created by leixing on 2024/7/31.
//

#pragma once


#include <cstdint>
#include <limits>
#include <algorithm>

// 强制 GLM 所有接受角度参数的函数都使用弧度，而不是度数, 以避免任何可能的混淆。
#define GLM_FORCE_RADIANS
// The perspective projection matrix generated by GLM will use the OpenGL depth range of -1.0 to 1.0 by default.
// We need to configure it to use the Vulkan range of 0.0 to 1.0 using the GLM_FORCE_DEPTH_ZERO_TO_ONE definition.
#define GLM_FORCE_DEPTH_ZERO_TO_ONE

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>

#define GLM_ENABLE_EXPERIMENTAL

#include <glm/gtx/hash.hpp>


#include <chrono>

// That way GLFW will include its own definitions and automatically load the Vulkan header with it.
//#define GLFW_INCLUDE_VULKAN
//#include <GLFW/glfw3.h>

#include "vulkan/vulkan.hpp"
#include "vulkan/QueueFamilyIndices.h"
#include "vulkan/SwapChainSupportDetail.h"
#include "TriangleVertex.h"

class VulkanRenderer {

public:
    // public fields

private:
    const std::array<float, 4> mClearColor = {0.0f, 0.0f, 0.0f, 1.0f};

    const char *VERTEX_SHADER_PATH = "shader/triangle/vertex.spv";
    const char *FRAGMENT_SHADER_PATH = "shader/triangle/fragment.spv";

    vk::Extent2D mMappingExtent = vk::Extent2D(1920, 1080);
    vk::SurfaceFormatKHR mMappingImageFormat = vk::Format::eB8G8R8A8Srgb;

    // 同时处理的帧数
    const int MAX_FRAMES_IN_FLIGHT = 2;

    const std::vector<const char *> mValidationLayers = {
            "VK_LAYER_KHRONOS_validation"
    };

    const std::vector<const char *> mRequiredExtensions = {

    };

    vk::SampleCountFlagBits mMsaaSamples;

    const bool mEnableValidationLayer = true;

    vk::Instance mInstance;

    vk::DebugUtilsMessengerEXT mDebugMessenger;

    // 物理设备
    vk::PhysicalDevice mPhysicalDevice;

    // 逻辑设备
    vk::Device mDevice;

    // 图形相关的任务队列
    vk::Queue mGraphicsQueue;

    vk::RenderPass mRenderPass;

    vk::DescriptorSetLayout mDescriptorSetLayout;

    vk::PipelineLayout mPipelineLayout;

    vk::Pipeline mGraphicsPipeline;

    vk::CommandPool mCommandPool;

    std::vector<vk::CommandBuffer> mCommandBuffers;

    std::vector<vk::Semaphore> mImageAvailableSemaphores;

    std::vector<vk::Semaphore> mRenderFinishedSemaphores;

    std::vector<vk::Fence> mInFlightFences;

    uint32_t mCurrentFrame = 0;

    std::vector<TriangleVertex> mTriangleVertices;

    std::vector<uint32_t> mTriangleIndices;

    vk::Buffer mVertexBuffer;

    vk::DeviceMemory mVertexBufferMemory;

    vk::Buffer mIndexBuffer;

    vk::DeviceMemory mIndexBufferMemory;

    vk::DescriptorPool mDescriptorPool;

    std::vector<vk::DescriptorSet> mDescriptorSets;

    vk::Image mMappingImage;
    vk::DeviceMemory mMappingImageDeviceMemory;
    vk::ImageView mMappingImageView;

    vk::Image mResolvedImage;
    vk::DeviceMemory mResolvedImageDeviceMemory;
    vk::ImageView mResolvedImageView;

    vk::Framebuffer mMappingFrameBuffer;

    vk::Buffer mTransferBuffer;
    vk::DeviceMemory mTransferBufferDeviceMemory;

    void *mMappingData;
    uint64_t mMappingDataSize;

public:
    VulkanRenderer();

    ~VulkanRenderer();

    void drawFrame();

    void *getMappingData();

    uint64_t getMappingDataSize();

    void copyImageToBuffer();

private:
    void initVulkan();

    void cleanUp();

    void createInstance();

    bool checkValidationLayerSupported();

    std::vector<const char *> getRequiredExtensions();

    void setupDebugMessenger();

    void destroyDebugUtilsMessengerExt(const vk::AllocationCallbacks *pAllocator);

    void pickPhysicalDevice();

    bool isDeviceSuitable(vk::PhysicalDevice device);

    void createLogicalDevice();

    QueueFamilyIndices findQueueFamilies(vk::PhysicalDevice &device);

    bool isDeviceSupportedRequiredExtensions(vk::PhysicalDevice device);

    void createGraphicsPipeline();

    vk::ShaderModule createShaderModule(const std::vector<char> &code);

    void createRenderPass();

    void createCommandPool();

    void createCommandBuffers();

    void recordCommandBuffer(const vk::CommandBuffer &commandBuffer, vk::Framebuffer &framebuffer);

    void createSyncObjects();

    void cleanSyncObjects();

    uint32_t findMemoryType(uint32_t typeFilter, vk::MemoryPropertyFlags properties);

    std::pair<vk::Buffer, vk::DeviceMemory> createBuffer(vk::DeviceSize size, vk::BufferUsageFlags usage, vk::MemoryPropertyFlags properties);

    void copyBuffer(vk::Buffer srcBuffer, vk::Buffer dstBuffer, vk::DeviceSize size);

    std::pair<vk::Image, vk::DeviceMemory> createImage(uint32_t width, uint32_t height, uint32_t mipLevels, vk::SampleCountFlagBits numSamples,
                                                       vk::Format format, vk::ImageTiling imageTiling,
                                                       vk::ImageUsageFlags imageUsage, vk::MemoryPropertyFlags memoryProperty);

    vk::CommandBuffer beginSingleTimeCommands();

    void endSingleTimeCommands(vk::CommandBuffer &commandBuffer);

    void transitionImageLayout(vk::Image image, vk::Format format, vk::ImageLayout oldImageLayout, vk::ImageLayout newImageLayout, uint32_t mipLevels);

    void copyBufferToImage(vk::Buffer buffer, vk::Image image, uint32_t width, uint32_t height);

    void copyImageToBuffer(vk::Image image, vk::Buffer buffer, uint32_t width, uint32_t height);

    vk::ImageView createImageView(const vk::Image &image, vk::Format format, vk::ImageAspectFlags imageAspect, uint32_t mipLevels);

    vk::Format findSupportedFormat(const std::vector<vk::Format> &candidates, vk::ImageTiling tiling, vk::FormatFeatureFlags features);

    vk::Format findDepthFormat();

    bool hasStencilComponent(vk::Format format);

    void loadTriangleModel();

    vk::SampleCountFlagBits getMaxUsableSampleCount();

    void createMappedImage();

    void createMappingFrameBuffer();

    void createTransferBuffer();

    void createTriangleVertexBuffer();

    void createTriangleIndexBuffer();

    void resolveMultisampledImage(vk::Image srcImage, vk::Image dstImage, uint32_t width, uint32_t height);
};

vk::Result CreateDebugUtilsMessengerEXT(vk::Instance instance,
                                        const vk::DebugUtilsMessengerCreateInfoEXT *pCreateInfo,
                                        const vk::AllocationCallbacks *pAllocator,
                                        vk::DebugUtilsMessengerEXT *pDebugMessenger);

void DestroyDebugUtilsMessengerEXT(vk::Instance instance, vk::DebugUtilsMessengerEXT debugMessenger, const vk::AllocationCallbacks *pAllocator);

void populateDebugMessengerCreateInfo(vk::DebugUtilsMessengerCreateInfoEXT &createInfo);